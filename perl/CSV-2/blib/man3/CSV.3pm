.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CSV 3pm"
.TH CSV 3pm "2001-08-18" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
CSV.pm \- a module providing manipulation routines for comma separated value (CSV) records
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use CSV;
.Ve
.PP
.Vb 8
\&    %fieldLayout = CSVinit($firstRecord);
\&    if (! CSVvalidate(%CSVfields, I<field list>)) {
\&        die "Fields missing."};
\&    }
\&    while (<INPUT>) { 
\&        @record = CSVsplit($_);
\&        I<process the records>;
\&      }
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c)2001 Christopher Rath <\f(CW\*(C`Christopher@Rath.ca\*(C'\fR> and Mark Mielke
<\f(CW\*(C`Mark@Mielke.cc\*(C'\fR>.
.PP
Distributed under the \s-1GNU\s0 Lesser General Public License v2.1.  See the
accompanying \f(CW\*(C`lgpl.txt\*(C'\fR file for the license text; if the file was missing you
may always obtain a copy from \f(CW\*(C`http://www.fsf.org/\*(C'\fR.
.SH "WARRANTY"
.IX Header "WARRANTY"
This program is distributed in the hope that it will be useful, but \fBwithout
any warranty\fR; without even the implied warranty of \fBmerchantability\fR or
\&\fBfitness for a particular purpose\fR.  See the \s-1GNU\s0 General Public License for
more details.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module defines some functions for reading comma separated value (\s-1CSV\s0)
files (e.g., Remedy-ARS generated files).  The module also allows some a
delimiter other than a comma to be used, or a selection of delimiters to be
used (e.g., comma and semicolon).
.PP
The \fBCSVinit(\fR\fI$firstRecord\fR\fB)\fR function is used to parse the initial record
of a \s-1CSV\s0 file; which by definition will contain the field names for each field
in the \s-1CSV\s0 records which follow in the file.  This initial record is itself a
\&\s-1CSV\s0 record.
.PP
The \fBCSVvalidate(\fR\fI\e%output_from_CSVinit\fR\fB,\fR <\fIfield_list\fR>\fB)\fR function
is used to verify that the incoming file contains the full list of fields
specified in the \fIfield_list\fR provided to the function.
.PP
The \fBCSVsplit(\fR\fI$rawRecord\fR\fB)\fR function splits a line, passed as
\&\fI$rawRecord\fR (a \s-1CSV\s0 record), and returns it split into fields; sort-of like
\&\fB\f(BIsplit()\fB\fR.
.PP
The \fB$CSV::Delimiters\fR variable can be set to specify an alternate, or set of
alternate, field delimiters.  In general, it should be specified as a \fBlocal\fR.
.PP
The \fBCSVjoin(\fR\fI@fields_to_join\fR\fB)\fR function takes an array of fields and
turns them into a comma separated value record.  If \fB$CSV::Delimiters\fR has
been used to specify multiple delimiters then \fB\f(BICSVjoin()\fB\fR will use the first
delimiter of the set for creation of \s-1CSV\s0 records.
.SH "USAGE"
.IX Header "USAGE"
A sample application (Demo_App) of this module has been provided in order to
demonstrate how it can be used.  Some additional usage notes follow.
.Sh "CSV::Delimiters"
.IX Subsection "CSV::Delimiters"
.Vb 3
\&    local $CSV::Delimiters = ",;";
\&    %fieldLayout = CSVinit($firstRecord);
\&    @Fields = CSVsplit($aRawRecord);
.Ve
.PP
This will cause either of '\fB,\fR' or '\fB;\fR' to be valid delimiters, even if
mixed.  \fB\f(BIlocal()\fB\fR is used to temporarily override the value, instead of
permanently overriding the value.
.PP
\&\fB\f(BICSVjoin()\fB\fR will prefer the first character in the Delimiters string, or the old
behaviour of a ',' if the Delimiters string is not defined.
.PP
If you peek at the code, it actually implements the split core twice.  The
first with \fB$CSV::Delimiters\fR, and the second with '\fB,\fR' hard\-coded.  This is
to maintain efficiency for code that does not make use of a dynamic set of
delimiter characters.
.Sh "\fICSVinit()\fP"
.IX Subsection "CSVinit()"
\&\fB\f(BICSVinit()\fB\fR is used to initialize the data structures for further \s-1CSV\s0 parsing.
The function scans the input record passed to it.  If it contains data, then
that data is used to define the field titles.  If no data is passed then some
default column data is used instead.  The function returns an associative array
containing field names and the corresponding field number.
.PP
\fIParameters\fR
.IX Subsection "Parameters"
.PP
[1] \f(CW$rawRecord\fR \- Record defining field layouts.
.PP
\fIReturns\fR
.IX Subsection "Returns"
.PP
Returns an associative array of field layout.
.Sh "\fICSVvalidate()\fP"
.IX Subsection "CSVvalidate()"
\&\fB\f(BICSVvalidate()\fB\fR is used to validate a set of field names.  A list of fields is
validated against the associative array previously built by a call to
\&\fICSVinit()\fR.  Returns true or false.
.PP
\fIParameters\fR
.IX Subsection "Parameters"
.PP
[1] \e%fields \- the fields as built by \fICSVinit()\fR. (reference)
.PP
[?] $...     \- a list of field names to check.
.PP
\fIReturns\fR
.IX Subsection "Returns"
.PP
Returns 0 if any single field is not found in \f(CW%fields\fR; otherwise 1.
.Sh "\fICSVjoin()\fP"
.IX Subsection "CSVjoin()"
\&\fB\f(BICSVjoin()\fB\fR is used to join \s-1CSV\s0 data.
.PP
\fIParameters\fR
.IX Subsection "Parameters"
.PP
Context 1:
.PP
.Vb 3
\&    [1] \e@fields  \- An array of fields to join into a CSV.
\&    [2] "minimum"|"quoteall" \- Defaults to "minimum", define 
\&            whether fields must be quoted when not req\(aqd.
.Ve
.PP
Context 2:
.PP
.Vb 2
\&    [?] $... \- An array of fields to join into 
\&            a CSV.
.Ve
.PP
\fIReturns\fR
.IX Subsection "Returns"
.PP
Returns a string which may be \*(L"un\*(R"join'ed using \fICSVsplit()\fR.
except in the case of a newline contained within a field)
.Sh "\fICSVsplit()\fP"
.IX Subsection "CSVsplit()"
\&\fBCSVsplit\fR is used to split \s-1CSV\s0 data, just like Perl's own \fIsplit()\fR does.
.PP
\fIParameters [1] \f(CI$rawRecord\fI \- the record to split.\fR
.IX Subsection "Parameters [1] $rawRecord - the record to split."
.PP
\fIReturns\fR
.IX Subsection "Returns"
.PP
Returns an array of values split out of \f(CW$rawRecord\fR.
.SH "TESTING"
.IX Header "TESTING"
Put the following lines into a file to test the comma-based parsing of this
module:
.PP
.Vb 1
\&    #!/usr/bin/perl \-w
.Ve
.PP
.Vb 1
\&    use CSV;
.Ve
.PP
.Vb 3
\&    while (<DATA>) {
\&        print join(":", CSVsplit($_)), "\en";
\&    }
.Ve
.PP
.Vb 8
\&    __DATA__
\&    "One from FAQ will do","sec""ond"
\&    "But, not","3rd""","or","""fifth"
\&    "don\(aqt","forget","fourth"",""","and"  ,  """,""sixth".
\&    "Of course, it doesn\(aqt solve",everything,8,N,1
\&    "Is there a new emacs   perl\-mode?"
\&    "Tom","tom@fiction.org"
\&    Empty fields needed,,"and "wanted
.Ve
.PP
.Vb 5
\&    Some,"",boundary  ",cases"",  ,too
\&    Grok this\e, Spok!
\&    "Didn\(aqt you notice\e! in it \e{the spec\e}"
\&    "Multi\-
\&    line",test
.Ve
.PP
This will produce the following output:
.PP
.Vb 7
\&    One from FAQ will do:sec"ond
\&    But, not:3rd":or:"fifth
\&    don\(aqt:forget:fourth",":"and"  :  """:""sixth".
\&    Of course, it doesn\(aqt solve:everything:8:N:1
\&    Is there a new emacs   perl\-mode?
\&    Tom:tom@fiction.org
\&    Empty fields needed::"and "wanted
.Ve
.PP
.Vb 5
\&    Some::boundary  ":cases"":  :too
\&    Grok this\e: Spok!
\&    Didn\(aqt you notice\e! in it \e{the spec\e}
\&    "Multi\-
\&    line":test
.Ve
.SH "CSV SPECIFICATION"
.IX Header "CSV SPECIFICATION"
This section attempts to define \s-1CSV\s0 records and files in a fairly rigorous
fashion.  The point behind this is to make this module usable without having to
read and understand the source code.
.Sh "\s-1CSV\s0 Records"
.IX Subsection "CSV Records"
The basic idea behind a \s-1CSV\s0 record is this: literal field values are
delimited by commas.  The immediate complication that arises is, of
course, ``What should be done when a comma must appear within a
field?''  Within the bounds of current practice, there are two
immediate solutions to this complication:
.IP "1." 4
Use a predefined escape character to tag commas which appear within fields.
.IP "2." 4
Allow quotation marks to enclose a field and _protect_ a comma appearing within
a field.
.PP
As with all work\-arounds, these \*(L"immediate solutions\*(R" have complications of
their own (these secondary complications are numbered the same as their primary
counterparts):
.IP "1." 4
Escape characters must themselves be escaped in order to appear as a value
within a field (e.g., if a literal comma is expressed as ``\e,'', then a literal
backslash must appear as ``\e\e'').
.IP "2." 4
Quotation marks must somehow be protected if they are to appear as a literal
character within a field.
.PP
Given that the essence of \s-1CSV\s0 files is simplicity, I have decided to reject
\&\fIall\fR escape and escaped characters with the exception of quoation marks
appearing within quotation marks.  That is, the case of the escaped comma has
been rejected from this specification.
.PP
Within the context of Perl, the \fIstring\fR\|(3) library and the \s-1UNIX\s0 shells, an
additional level of complexity is added to this equation when we begin to ask,
``What is the meaning or significance of whitespace within a \s-1CSV\s0 record?''  The
meaning of whitespace is a key technical detail which must be accounted for in
both the specification and its implementation; otherwise, everyone's
implementation will produce semi-random results based upon that implementors
opinion regarding whitespace.
.Sh "Semi-Formal \s-1CSV\s0 Record Specification"
.IX Subsection "Semi-Formal CSV Record Specification"
This specification uses the syntax described in Appendix\ A of the first
edition of O'Reilly's Programming Perl book (i.e., the Perl\ 4 camel book).
.PP
.Vb 1
\&    CSV_RECORD ::= (* FIELD DELIM *) FIELD REC_SEP
.Ve
.PP
.Vb 1
\&    FIELD ::= QUOTED_TEXT | TEXT
.Ve
.PP
.Vb 1
\&    DELIM ::= `,\(aq
.Ve
.PP
.Vb 1
\&    REC_SEP ::= `\en\(aq
.Ve
.PP
.Vb 1
\&    TEXT ::= LIT_STR | ["] LIT_STR [^"] | [^"] LIT_STR ["]
.Ve
.PP
.Vb 1
\&    LIT_STR ::= (* LITERAL_CHAR *)
.Ve
.PP
.Vb 1
\&    LITERAL_CHAR ::= NOT_COMMA_NL
.Ve
.PP
.Vb 1
\&    NOT_COMMA_NL ::= [^,\en]
.Ve
.PP
.Vb 1
\&    QUOTED_TEXT ::= ["] (* NOT_A_QUOTE *) ["]
.Ve
.PP
.Vb 1
\&    NOT_A_QUOTE ::= [^"] | ESCAPED_QUOTE
.Ve
.PP
.Vb 1
\&    ESCAPED_QUOTE ::= `""\(aq
.Ve
.Sh "Notes"
.IX Subsection "Notes"
This specification does not grant any special status to whitespace characters.
This means that \fB\f(BIall whitespace is part of some field value.\fB\fR
.PP
The \fB\s-1TEXT\s0\fR non-terminal is attempting to express the cases where quotation
marks exist but do not completely encapsulate the field value; in cases like
this, the quotation marks should be treated as literal characters making up
part of the field value.
.PP
One ambiguity exist in this specification that I have been unable to properly
express.  The case of a field with the value ,abc"\*(L"de,.  Should the double
quotation marks be treated as an escaped quotation mark or as two quotation
marks?  I believe that occurences of \*(R"" should be treated as escaped quotation
marks \fIonly\fR within a quoted string.
.PP
The \fB\s-1LITERAL_CHAR\s0\fR non-terminal exists partially as a place\-holder.  Escaped
characters may be easily accomadated by this specification at a later date by
OR-ing them to the right side of \fB\s-1LITERAL_CHAR\s0\fR.
.PP
Some of the non-terminals exist solely as documentation/reading aids.  The
\&\fB\s-1NOT_A_COMMA_NL\s0\fR is one example of this case; its name helps express the
meaning of the regex (which should assist other readers of this document to
detect errors in the specification).
.PP
The \fB\s-1ESCAPED_QUOTE\s0\fR non-terminal includes the PASCAL-like case of ``"\*(L"'' and
excludes the more traditional \s-1UNIX\s0 ``\e\e\*(R"''.  This is not my preference; I have
included it here because I know there exists at least one commercial tool that
produces \s-1CSV\s0 records containing the PASCAL-like construct and not the UNIX-like
one.
.SH "AUTHORS"
.IX Header "AUTHORS"
Christopher Rath (\f(CW\*(C`christopher@rath.ca\*(C'\fR) wrote the \s-1CSV\s0 specification and
everything in the module except the essential snippet of code that actually
does the work :).
.PP
Mark Mielke (\f(CW\*(C`mark@mielke.cc\*(C'\fR) took the specification and wrote the essential
piece of code that actually breaks the \s-1CSV\s0 records into its constituent fields.
He also took the initial .pl version and .pm'ed it (this only makes sense,
since this module is only usable in perl5).
.SH "BUGS"
.IX Header "BUGS"
.Sh "Not Thread-Safe"
.IX Subsection "Not Thread-Safe"
This module, and hence \fB\f(BICSVinit()\fB\fR/\fB\f(BICSVsplit()\fB\fR, is not thread-safe or
re\-entrant.
.Sh "Fields Spanning Lines"
.IX Subsection "Fields Spanning Lines"
This module currently fails in one of the test\-cases, although the test output
listed herein, above, has been constructed to show the actual output of this
module, as opposed to the correct output:
.PP
.Vb 2
\&    "Multi\-
\&    line",test
.Ve
.PP
This is due to the fact that perl is reading one line at a time with:
.PP
.Vb 1
\&    while (<DATA>) { ... }
.Ve
.PP
So the first line is read (\*(L"Multi\-) and evaluated. The _second_ time around the
loop the second line (line\*(R",test) is read and evaluated.  There is no
workaround available, this is simply a limitation of the module.
.SH "VERSION"
.IX Header "VERSION"
The \s-1RCS\s0 identifier for this module is
$Id:\ \s-1CSV\s0.pm,v\ 1.10\ 2001/08/19\ 01:42:33\ christopher\ Exp\ $.
